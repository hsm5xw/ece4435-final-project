-- VHDL Entity lab9_new_lib.execute_stage.symbol
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 21:34:28 04/27/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY execute_stage IS
   PORT( 
      Control           : IN     std_logic_vector (15 DOWNTO 0);
      Dest              : IN     std_logic_vector (3 DOWNTO 0);
      Extra             : IN     std_logic_vector (15 DOWNTO 0);
      L                 : IN     std_logic_vector (15 DOWNTO 0);
      R                 : IN     std_logic_vector (15 DOWNTO 0);
      can_move_on       : IN     std_logic;
      clk               : IN     std_logic;
      pcval             : IN     std_logic_vector (15 DOWNTO 0);
      rst               : IN     std_logic;
      stall             : IN     std_logic;
      Control_Out       : OUT    std_logic_vector (2 DOWNTO 0);
      Dest_Execute_Out  : OUT    std_logic_vector (3 DOWNTO 0);
      Extra_Execute_Out : OUT    std_logic_vector (15 DOWNTO 0);
      Result            : OUT    std_logic_vector (15 DOWNTO 0);
      jaddress          : OUT    std_logic_vector (15 DOWNTO 0);
      jump              : OUT    std_logic
   );

-- Declarations

END execute_stage ;

--
-- VHDL Architecture lab9_new_lib.execute_stage.struct
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 08:49:57 04/29/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

LIBRARY lab9_new_lib;

ARCHITECTURE struct OF execute_stage IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL ALU_Result                 : std_logic_vector(15 DOWNTO 0);
   SIGNAL ALU_cin_Control            : std_logic_vector(1 DOWNTO 0);
   SIGNAL ALU_cout                   : std_logic;
   SIGNAL ALU_mode_Control           : std_logic;
   SIGNAL Additional_Execute_Control : std_logic_vector(3 DOWNTO 0);
   SIGNAL Carry_CCR_In               : std_logic;
   SIGNAL Carry_CCR_Out              : std_logic;
   SIGNAL Carry_CCR_enable           : std_logic;
   SIGNAL Control_Register_Out       : std_logic_vector(15 DOWNTO 0);
   SIGNAL Dest_Register_Out          : std_logic_vector(3 DOWNTO 0);
   SIGNAL Dest_bit10                 : std_logic;
   SIGNAL Dest_bit11                 : std_logic;
   SIGNAL Dest_bit12                 : std_logic;
   SIGNAL Dest_bit9                  : std_logic;
   SIGNAL Enable_Carry_CCR           : std_logic;
   SIGNAL Enable_VNZ_CCR             : std_logic;
   SIGNAL Execute_Control            : std_logic_vector(8 DOWNTO 0);
   SIGNAL Is_Branch                  : std_logic;
   SIGNAL Is_JAL                     : std_logic;
   SIGNAL Is_Unconditional_Jumps     : std_logic;
   SIGNAL Is_negative                : std_logic;
   SIGNAL Is_ovfl                    : std_logic;
   SIGNAL Is_zero                    : std_logic;
   SIGNAL L_Register_Out             : std_logic_vector(15 DOWNTO 0);
   SIGNAL Negative_CCR_Out           : std_logic;
   SIGNAL Overflow_CCR_Out           : std_logic;
   SIGNAL R_Register_Out             : std_logic_vector(15 DOWNTO 0);
   SIGNAL Result_Intermediate        : std_logic_vector(15 DOWNTO 0);
   SIGNAL VNZ_CCR_enable             : std_logic;
   SIGNAL Zero_CCR_Out               : std_logic;
   SIGNAL dout                       : std_logic;
   SIGNAL dout1                      : std_logic;
   SIGNAL dout10                     : std_logic;
   SIGNAL dout11                     : std_logic;
   SIGNAL dout12                     : std_logic;
   SIGNAL dout13                     : std_logic;
   SIGNAL dout14                     : std_logic;
   SIGNAL dout15                     : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout16                     : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout2                      : std_logic;
   SIGNAL dout3                      : std_logic;
   SIGNAL dout4                      : std_logic;
   SIGNAL dout5                      : std_logic;
   SIGNAL dout6                      : std_logic;
   SIGNAL dout7                      : std_logic;
   SIGNAL dout8                      : std_logic;
   SIGNAL dout9                      : std_logic_vector(3 DOWNTO 0);
   SIGNAL from_Shifter_Control       : std_logic;
   SIGNAL load_enable                : std_logic;
   SIGNAL next_pc_val                : std_logic_vector(15 DOWNTO 0);
   SIGNAL operation                  : std_logic_vector(3 DOWNTO 0);
   SIGNAL pcval_Register_Out         : std_logic_vector(15 DOWNTO 0);
   SIGNAL shifter_Out                : std_logic_vector(15 DOWNTO 0);
   SIGNAL to_Carry_CCR               : std_logic;


   -- ModuleWare signal declarations(v1.12) for instance 'Carry_CCR_Register' of 'adff'
   SIGNAL mw_Carry_CCR_Registerreg_cval : std_logic := '0';

   -- ModuleWare signal declarations(v1.12) for instance 'Control_Register' of 'adff'
   SIGNAL mw_Control_Registerreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'Dest_Register' of 'adff'
   SIGNAL mw_Dest_Registerreg_cval : std_logic_vector(3 DOWNTO 0) := "0000";

   -- ModuleWare signal declarations(v1.12) for instance 'Extra_Register' of 'adff'
   SIGNAL mw_Extra_Registerreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'L_Register' of 'adff'
   SIGNAL mw_L_Registerreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'Negative_CCR_Register' of 'adff'
   SIGNAL mw_Negative_CCR_Registerreg_cval : std_logic := '0';

   -- ModuleWare signal declarations(v1.12) for instance 'Overflow_CCR_Register' of 'adff'
   SIGNAL mw_Overflow_CCR_Registerreg_cval : std_logic := '0';

   -- ModuleWare signal declarations(v1.12) for instance 'R_Register' of 'adff'
   SIGNAL mw_R_Registerreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'Zero_CCR_Register' of 'adff'
   SIGNAL mw_Zero_CCR_Registerreg_cval : std_logic := '0';

   -- ModuleWare signal declarations(v1.12) for instance 'pcval_Register' of 'adff'
   SIGNAL mw_pcval_Registerreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'Additional_Execute_Control_Splitter' of 'split'
   SIGNAL mw_Additional_Execute_Control_Splittertemp_din : std_logic_vector(3 DOWNTO 0);

   -- ModuleWare signal declarations(v1.12) for instance 'Control_Splitter' of 'split'
   SIGNAL mw_Control_Splittertemp_din : std_logic_vector(15 DOWNTO 0);

   -- ModuleWare signal declarations(v1.12) for instance 'Dest_Splitter' of 'split'
   SIGNAL mw_Dest_Splittertemp_din : std_logic_vector(3 DOWNTO 0);

   -- ModuleWare signal declarations(v1.12) for instance 'Execute_Control_Splitter' of 'split'
   SIGNAL mw_Execute_Control_Splittertemp_din : std_logic_vector(8 DOWNTO 0);

   -- Component Declarations
   COMPONENT mini_ALU
   PORT (
      ALU_cin     : IN     std_logic ;
      ALU_mode    : IN     std_logic ;
      Left        : IN     std_logic_vector (15 DOWNTO 0);
      Right       : IN     std_logic_vector (15 DOWNTO 0);
      operation   : IN     std_logic_vector (3 DOWNTO 0);
      pcval       : IN     std_logic_vector (15 DOWNTO 0);
      ALU_Result  : OUT    std_logic_vector (15 DOWNTO 0);
      ALU_cout    : OUT    std_logic ;
      Is_negative : OUT    std_logic ;
      Is_ovfl     : OUT    std_logic ;
      Is_zero     : OUT    std_logic ;
      next_pc_val : OUT    std_logic_vector (15 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT mini_Shifter
   PORT (
      from_Carry_CCR  : IN     std_logic;
      shift_operation : IN     std_logic_vector (3 DOWNTO 0);
      shifter_In      : IN     std_logic_vector (15 DOWNTO 0);
      shifter_Out     : OUT    std_logic_vector (15 DOWNTO 0);
      to_Carry_CCR    : OUT    std_logic
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : mini_ALU USE ENTITY lab9_new_lib.mini_ALU;
   FOR ALL : mini_Shifter USE ENTITY lab9_new_lib.mini_Shifter;
   -- pragma synthesis_on


BEGIN

   -- ModuleWare code(v1.12) for instance 'Carry_CCR_Register' of 'adff'
   Carry_CCR_Out <= mw_Carry_CCR_Registerreg_cval;
   carry_ccr_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (rst = '1') THEN
            mw_Carry_CCR_Registerreg_cval <= '0';
         ELSIF (Carry_CCR_enable = '1') THEN
            mw_Carry_CCR_Registerreg_cval <= Carry_CCR_In;
         END IF;
      END IF;
   END PROCESS carry_ccr_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Control_Register' of 'adff'
   Control_Register_Out <= mw_Control_Registerreg_cval;
   control_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_Control_Registerreg_cval <= dout16;
         END IF;
      END IF;
   END PROCESS control_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Dest_Register' of 'adff'
   Dest_Register_Out <= mw_Dest_Registerreg_cval;
   dest_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_Dest_Registerreg_cval <= Dest;
         END IF;
      END IF;
   END PROCESS dest_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Extra_Register' of 'adff'
   Extra_Execute_Out <= mw_Extra_Registerreg_cval;
   extra_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_Extra_Registerreg_cval <= Extra;
         END IF;
      END IF;
   END PROCESS extra_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'L_Register' of 'adff'
   L_Register_Out <= mw_L_Registerreg_cval;
   l_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_L_Registerreg_cval <= L;
         END IF;
      END IF;
   END PROCESS l_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Negative_CCR_Register' of 'adff'
   Negative_CCR_Out <= mw_Negative_CCR_Registerreg_cval;
   negative_ccr_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (rst = '1') THEN
            mw_Negative_CCR_Registerreg_cval <= '0';
         ELSIF (VNZ_CCR_enable = '1') THEN
            mw_Negative_CCR_Registerreg_cval <= Is_negative;
         END IF;
      END IF;
   END PROCESS negative_ccr_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Overflow_CCR_Register' of 'adff'
   Overflow_CCR_Out <= mw_Overflow_CCR_Registerreg_cval;
   overflow_ccr_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (rst = '1') THEN
            mw_Overflow_CCR_Registerreg_cval <= '0';
         ELSIF (VNZ_CCR_enable = '1') THEN
            mw_Overflow_CCR_Registerreg_cval <= Is_ovfl;
         END IF;
      END IF;
   END PROCESS overflow_ccr_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'R_Register' of 'adff'
   R_Register_Out <= mw_R_Registerreg_cval;
   r_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_R_Registerreg_cval <= R;
         END IF;
      END IF;
   END PROCESS r_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'Zero_CCR_Register' of 'adff'
   Zero_CCR_Out <= mw_Zero_CCR_Registerreg_cval;
   zero_ccr_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (rst = '1') THEN
            mw_Zero_CCR_Registerreg_cval <= '0';
         ELSIF (VNZ_CCR_enable = '1') THEN
            mw_Zero_CCR_Registerreg_cval <= Is_zero;
         END IF;
      END IF;
   END PROCESS zero_ccr_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'pcval_Register' of 'adff'
   pcval_Register_Out <= mw_pcval_Registerreg_cval;
   pcval_registerseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (load_enable = '1') THEN
            mw_pcval_Registerreg_cval <= pcval;
         END IF;
      END IF;
   END PROCESS pcval_registerseq_proc;

   -- ModuleWare code(v1.12) for instance 'CCR_bitmask' of 'and'
   dout13 <= Is_Branch AND dout6;

   -- ModuleWare code(v1.12) for instance 'Carry_CCR_load_AND' of 'and'
   Carry_CCR_enable <= Enable_Carry_CCR AND load_enable;

   -- ModuleWare code(v1.12) for instance 'Carry_bitmask_AND' of 'and'
   dout10 <= Carry_CCR_Out AND Dest_bit12;

   -- ModuleWare code(v1.12) for instance 'Negative_bitmaskt_AND' of 'and'
   dout12 <= Negative_CCR_Out AND Dest_bit10;

   -- ModuleWare code(v1.12) for instance 'Overflow_bitmask_AND' of 'and'
   dout11 <= Overflow_CCR_Out AND Dest_bit11;

   -- ModuleWare code(v1.12) for instance 'VNZ_CCR_load_AND' of 'and'
   VNZ_CCR_enable <= Enable_VNZ_CCR AND load_enable;

   -- ModuleWare code(v1.12) for instance 'Zero_bitmask_AND' of 'and'
   dout5 <= Zero_CCR_Out AND Dest_bit9;

   -- ModuleWare code(v1.12) for instance 'jaddress_Buff' of 'buff'
   jaddress <= Result_Intermediate;

   -- ModuleWare code(v1.12) for instance 'ALU_MODE_ONE' of 'constval'
   dout1 <= '1';

   -- ModuleWare code(v1.12) for instance 'ALU_MODE_ZERO' of 'constval'
   dout <= '0';

   -- ModuleWare code(v1.12) for instance 'ALU_cin_ONE' of 'constval'
   dout3 <= '1';

   -- ModuleWare code(v1.12) for instance 'ALU_cin_ZERO' of 'constval'
   dout2 <= '0';

   -- ModuleWare code(v1.12) for instance 'Control_ZERO' of 'constval'
   dout15 <= "0000000000000000";

   -- ModuleWare code(v1.12) for instance 'FOURTEEN' of 'constval'
   dout9 <= "1110";

   -- ModuleWare code(v1.12) for instance 'jump_ONE' of 'constval'
   dout4 <= '1';

   -- ModuleWare code(v1.12) for instance 'Carry_CCR_inverter' of 'inv'
   dout7 <= NOT(Carry_CCR_Out);

   -- ModuleWare code(v1.12) for instance 'stall_inverter' of 'inv'
   load_enable <= NOT(stall);

   -- ModuleWare code(v1.12) for instance 'ALU_cin_MUX' of 'mux'
   alu_cin_muxcombo_proc: PROCESS(dout2, Carry_CCR_Out, dout3, dout7, 
                                  ALU_cin_Control)
   BEGIN
      CASE ALU_cin_Control IS
      WHEN "00" => dout8 <= dout2;
      WHEN "01" => dout8 <= Carry_CCR_Out;
      WHEN "10" => dout8 <= dout3;
      WHEN "11" => dout8 <= dout7;
      WHEN OTHERS => dout8 <= 'X';
      END CASE;
   END PROCESS alu_cin_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'ALU_mode_MUX' of 'mux'
   alu_mode_muxcombo_proc: PROCESS(dout, dout1, ALU_mode_Control)
   BEGIN
      CASE ALU_mode_Control IS
      WHEN '0' => dout14 <= dout;
      WHEN '1' => dout14 <= dout1;
      WHEN OTHERS => dout14 <= 'X';
      END CASE;
   END PROCESS alu_mode_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'Carry_CCR_MUX' of 'mux'
   carry_ccr_muxcombo_proc: PROCESS(ALU_cout, to_Carry_CCR, 
                                    from_Shifter_Control)
   BEGIN
      CASE from_Shifter_Control IS
      WHEN '0' => Carry_CCR_In <= ALU_cout;
      WHEN '1' => Carry_CCR_In <= to_Carry_CCR;
      WHEN OTHERS => Carry_CCR_In <= 'X';
      END CASE;
   END PROCESS carry_ccr_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'Control_Input_MUX' of 'mux'
   control_input_muxcombo_proc: PROCESS(dout15, Control, can_move_on)
   BEGIN
      CASE can_move_on IS
      WHEN '0' => dout16 <= dout15;
      WHEN '1' => dout16 <= Control;
      WHEN OTHERS => dout16 <= (OTHERS => 'X');
      END CASE;
   END PROCESS control_input_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'Dest_Execute_Out_MUX' of 'mux'
   dest_execute_out_muxcombo_proc: PROCESS(Dest_Register_Out, dout9, 
                                           Is_JAL)
   BEGIN
      CASE Is_JAL IS
      WHEN '0' => Dest_Execute_Out <= Dest_Register_Out;
      WHEN '1' => Dest_Execute_Out <= dout9;
      WHEN OTHERS => Dest_Execute_Out <= (OTHERS => 'X');
      END CASE;
   END PROCESS dest_execute_out_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'Result_Intermediate' of 'mux'
   result_intermediatecombo_proc: PROCESS(ALU_Result, shifter_Out, 
                                          from_Shifter_Control)
   BEGIN
      CASE from_Shifter_Control IS
      WHEN '0' => Result_Intermediate <= ALU_Result;
      WHEN '1' => Result_Intermediate <= shifter_Out;
      WHEN OTHERS => Result_Intermediate <= (OTHERS => 'X');
      END CASE;
   END PROCESS result_intermediatecombo_proc;

   -- ModuleWare code(v1.12) for instance 'Result_MUX' of 'mux'
   result_muxcombo_proc: PROCESS(Result_Intermediate, next_pc_val, 
                                 Is_JAL)
   BEGIN
      CASE Is_JAL IS
      WHEN '0' => Result <= Result_Intermediate;
      WHEN '1' => Result <= next_pc_val;
      WHEN OTHERS => Result <= (OTHERS => 'X');
      END CASE;
   END PROCESS result_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'jump_MUX' of 'mux'
   jump_muxcombo_proc: PROCESS(dout13, dout4, Is_Unconditional_Jumps)
   BEGIN
      CASE Is_Unconditional_Jumps IS
      WHEN '0' => jump <= dout13;
      WHEN '1' => jump <= dout4;
      WHEN OTHERS => jump <= 'X';
      END CASE;
   END PROCESS jump_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'CCR_bitmask_OR' of 'or'
   dout6 <= dout5 OR dout12 OR dout11 OR dout10;

   -- ModuleWare code(v1.12) for instance 'Additional_Execute_Control_Splitter' of 'split'
   mw_Additional_Execute_Control_Splittertemp_din <= Additional_Execute_Control;
   additional_execute_control_splittercombo_proc: PROCESS (mw_Additional_Execute_Control_Splittertemp_din)
   VARIABLE temp_din: std_logic_vector(3 DOWNTO 0);
   BEGIN
      temp_din := mw_Additional_Execute_Control_Splittertemp_din(3 DOWNTO 0);
      Enable_VNZ_CCR <= temp_din(0);
      Enable_Carry_CCR <= temp_din(1);
      Is_JAL <= temp_din(2);
      Is_Unconditional_Jumps <= temp_din(3);
   END PROCESS additional_execute_control_splittercombo_proc;

   -- ModuleWare code(v1.12) for instance 'Control_Splitter' of 'split'
   mw_Control_Splittertemp_din <= Control_Register_Out;
   control_splittercombo_proc: PROCESS (mw_Control_Splittertemp_din)
   VARIABLE temp_din: std_logic_vector(15 DOWNTO 0);
   BEGIN
      temp_din := mw_Control_Splittertemp_din(15 DOWNTO 0);
      Execute_Control <= temp_din(8 DOWNTO 0);
      Additional_Execute_Control <= temp_din(12 DOWNTO 9);
      Control_Out <= temp_din(15 DOWNTO 13);
   END PROCESS control_splittercombo_proc;

   -- ModuleWare code(v1.12) for instance 'Dest_Splitter' of 'split'
   mw_Dest_Splittertemp_din <= Dest_Register_Out;
   dest_splittercombo_proc: PROCESS (mw_Dest_Splittertemp_din)
   VARIABLE temp_din: std_logic_vector(3 DOWNTO 0);
   BEGIN
      temp_din := mw_Dest_Splittertemp_din(3 DOWNTO 0);
      Dest_bit9 <= temp_din(0);
      Dest_bit10 <= temp_din(1);
      Dest_bit11 <= temp_din(2);
      Dest_bit12 <= temp_din(3);
   END PROCESS dest_splittercombo_proc;

   -- ModuleWare code(v1.12) for instance 'Execute_Control_Splitter' of 'split'
   mw_Execute_Control_Splittertemp_din <= Execute_Control;
   execute_control_splittercombo_proc: PROCESS (mw_Execute_Control_Splittertemp_din)
   VARIABLE temp_din: std_logic_vector(8 DOWNTO 0);
   BEGIN
      temp_din := mw_Execute_Control_Splittertemp_din(8 DOWNTO 0);
      Is_Branch <= temp_din(0);
      from_Shifter_Control <= temp_din(1);
      ALU_cin_Control <= temp_din(3 DOWNTO 2);
      operation <= temp_din(7 DOWNTO 4);
      ALU_mode_Control <= temp_din(8);
   END PROCESS execute_control_splittercombo_proc;

   -- Instance port mappings.
   U_0 : mini_ALU
      PORT MAP (
         ALU_cin     => dout8,
         ALU_mode    => dout14,
         Left        => L_Register_Out,
         Right       => R_Register_Out,
         operation   => operation,
         pcval       => pcval_Register_Out,
         ALU_Result  => ALU_Result,
         ALU_cout    => ALU_cout,
         Is_negative => Is_negative,
         Is_ovfl     => Is_ovfl,
         Is_zero     => Is_zero,
         next_pc_val => next_pc_val
      );
   U_1 : mini_Shifter
      PORT MAP (
         shifter_In      => L_Register_Out,
         shift_operation => operation,
         shifter_Out     => shifter_Out,
         from_Carry_CCR  => Carry_CCR_Out,
         to_Carry_CCR    => to_Carry_CCR
      );

END struct;
