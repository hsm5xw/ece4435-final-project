-- VHDL Entity lab9_new_lib.mini_ALU.symbol
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 03:34:23 04/26/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY mini_ALU IS
   PORT( 
      ALU_cin     : IN     std_logic;
      ALU_mode    : IN     std_logic;
      Left        : IN     std_logic_vector (15 DOWNTO 0);
      Right       : IN     std_logic_vector (15 DOWNTO 0);
      operation   : IN     std_logic_vector (3 DOWNTO 0);
      pcval       : IN     std_logic_vector (15 DOWNTO 0);
      ALU_Result  : OUT    std_logic_vector (15 DOWNTO 0);
      ALU_cout    : OUT    std_logic;
      Is_negative : OUT    std_logic;
      Is_ovfl     : OUT    std_logic;
      Is_zero     : OUT    std_logic;
      next_pc_val : OUT    std_logic_vector (15 DOWNTO 0)
   );

-- Declarations

END mini_ALU ;

--
-- VHDL Architecture lab9_new_lib.mini_ALU.struct
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 03:34:23 04/26/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;


ARCHITECTURE struct OF mini_ALU IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL dout  : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout1 : std_logic_vector(15 DOWNTO 0);

   -- Implicit buffer signal declarations
   SIGNAL ALU_Result_internal : std_logic_vector (15 DOWNTO 0);


   -- ModuleWare signal declarations(v1.12) for instance 'custom_ALU' of 'alu181'
   SIGNAL mw_custom_ALUa_in : std_logic_vector(15 DOWNTO 0);
   SIGNAL mw_custom_ALUb_in : std_logic_vector(15 DOWNTO 0);
   SIGNAL mw_custom_ALUaout : unsigned(15 DOWNTO 0);
   SIGNAL mw_custom_ALUlout : std_logic_vector(15 DOWNTO 0);
   SIGNAL mw_custom_ALUcarryout : std_logic;


BEGIN

   -- ModuleWare code(v1.12) for instance 'custom_Adder' of 'add'
   custom_addercombo_proc: PROCESS (pcval, dout1)
   VARIABLE temp_din0 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_din1 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_sum : unsigned(16 DOWNTO 0);
   VARIABLE temp_carry : std_logic;
   BEGIN
      temp_din0 := '0' & pcval;
      temp_din1 := '0' & dout1;
      temp_carry := '0';
      temp_sum := unsigned(temp_din0) + unsigned(temp_din1) + temp_carry;
      next_pc_val <= conv_std_logic_vector(temp_sum(15 DOWNTO 0),16);
   END PROCESS custom_addercombo_proc;

   -- ModuleWare code(v1.12) for instance 'custom_ALU' of 'alu181'
   ALU_cout <= mw_custom_ALUcarryout AND (NOT(ALU_mode));
   Is_ovfl <= (mw_custom_ALUcarryout) AND (NOT(ALU_mode));
   custom_aluarith_proc: PROCESS (mw_custom_ALUa_in, mw_custom_ALUb_in, ALU_cin)
   VARIABLE temp_atemp : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_btemp : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_otemp : unsigned(16 DOWNTO 0);
   VARIABLE temp_carryin : std_logic;
   BEGIN
      temp_atemp := '0' & mw_custom_ALUa_in;
      temp_btemp := '0' & mw_custom_ALUb_in;
      temp_carryin := ALU_cin;
      temp_otemp := (unsigned(temp_atemp) + unsigned(temp_btemp) + temp_carryin);
      mw_custom_ALUaout <= temp_otemp(15 DOWNTO 0);
      mw_custom_ALUcarryout <= temp_otemp(16) ;
   END PROCESS custom_aluarith_proc;
   
   custom_alufdrive_proc: PROCESS (mw_custom_ALUaout, mw_custom_ALUlout, ALU_mode)
   BEGIN
      IF (ALU_mode = '1') THEN
         ALU_Result_internal <= mw_custom_ALUlout;
      ELSIF (ALU_mode = '0') THEN
         ALU_Result_internal <= std_logic_vector(mw_custom_ALUaout);
      ELSE
         ALU_Result_internal <= (OTHERS => 'X');
      END IF;
   END PROCESS custom_alufdrive_proc;
   
   
   custom_alumux_proc: PROCESS (operation, Left, Right)
   VARIABLE temp_or0 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_and0 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_not_a : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_tain0 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_or1 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_and1 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_not_b : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_tain1 : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_orout : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_andout : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_xorout : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_ltemp : std_logic_vector(15 DOWNTO 0);
   VARIABLE temp_s3_0 : std_logic_vector (3 DOWNTO 0);
   CONSTANT S0 :std_logic_vector(3 DOWNTO 0 ) := "0000";
   CONSTANT S1 :std_logic_vector(3 DOWNTO 0 ) := "0001";
   CONSTANT S2 :std_logic_vector(3 DOWNTO 0 ) := "0010";
   CONSTANT S3 :std_logic_vector(3 DOWNTO 0 ) := "0011";
   CONSTANT S4 :std_logic_vector(3 DOWNTO 0 ) := "0100";
   CONSTANT S5 :std_logic_vector(3 DOWNTO 0 ) := "0101";
   CONSTANT S6 :std_logic_vector(3 DOWNTO 0 ) := "0110";
   CONSTANT S7 :std_logic_vector(3 DOWNTO 0 ) := "0111";
   CONSTANT S8 :std_logic_vector(3 DOWNTO 0 ) := "1000";
   CONSTANT S9 :std_logic_vector(3 DOWNTO 0 ) := "1001";
   CONSTANT S10 :std_logic_vector(3 DOWNTO 0 ) := "1010";
   CONSTANT S11 :std_logic_vector(3 DOWNTO 0 ) := "1011";
   CONSTANT S12 :std_logic_vector(3 DOWNTO 0 ) := "1100";
   CONSTANT S13 :std_logic_vector(3 DOWNTO 0 ) := "1101";
   CONSTANT S14 :std_logic_vector(3 DOWNTO 0 ) := "1110";
   CONSTANT S15 :std_logic_vector(3 DOWNTO 0 ) := "1111";
   BEGIN
      temp_s3_0 := operation;
      temp_or1 := (OTHERS => '0');
      temp_or0 := (OTHERS => '0');
      temp_and1 := (OTHERS => '1');
      temp_and0 := (OTHERS => '1');
      temp_not_a := NOT(Left);
      temp_not_b := NOT(Right);
      CASE temp_s3_0 IS
      WHEN S1 =>
         temp_or0 := temp_not_a;
         temp_or1 := temp_not_b;
         temp_and0 := Left;
         temp_and1 := Right;
      WHEN S2 =>
         temp_or0 := temp_not_a;
         temp_or1 := Right;
         temp_and0 := Left;
         temp_and1 := temp_not_b;
      WHEN S4 =>
         temp_and0 := temp_not_a;
         temp_and1 := temp_not_b;
         temp_or0 := Left;
         temp_or1 := temp_not_b;
      WHEN S5 =>
         temp_and0 := Left;
         temp_and1 := Right;
         temp_or0 := Left;
         temp_or1 := temp_not_b;
      WHEN S6 =>
         temp_and0 := temp_not_a;
         temp_and1 := temp_not_b;
      WHEN S7 =>
         temp_or0 := Left;
         temp_or1 := temp_not_b;
      WHEN S8 =>
         temp_and0 := temp_not_a;
         temp_and1 := Right;
         temp_or0 := Left;
         temp_or1 := Right;
      WHEN S9 =>
         temp_or0 := Left;
         temp_or1 := Right;
      WHEN S10 =>
         temp_and0 := Left;
         temp_and1 := temp_not_b;
         temp_or0 := Left;
         temp_or1 := Right;
      WHEN S11 =>
         temp_or0 := Left;
         temp_or1 := Right;
      WHEN S13 | S14 =>
         temp_and0 := Left;
         temp_and1 := Right;
         temp_or0 := temp_not_a;
         temp_or1 := Right;
      WHEN OTHERS =>
         temp_and0 := (OTHERS => 'X');
         temp_and1 := (OTHERS => 'X');
         temp_or0 := (OTHERS => 'X');
         temp_or1 := (OTHERS => 'X');
      END CASE;
      temp_xorout := Left XOR Right;
      temp_andout := temp_and0 AND temp_and1;
      temp_orout := temp_or0 OR temp_or1;
      temp_tain0 := (OTHERS => '0');
      temp_tain1 := (OTHERS => '1'); -- minus 1
      temp_ltemp := (OTHERS => '0');
      CASE temp_s3_0 IS
      WHEN S0 =>
         temp_ltemp := temp_not_a;
         temp_tain0 := Left;
      WHEN S1 | S2 =>
         temp_ltemp := temp_orout;
         temp_tain0 := temp_andout;
      WHEN S3 =>
         temp_ltemp := (OTHERS => '0');
         temp_ltemp(0) := '1';
      WHEN S4 =>
         temp_ltemp := temp_andout;
         temp_tain0 := Left;
         temp_tain1 := temp_orout;
      WHEN S5 =>
         temp_ltemp := temp_not_b;
         temp_tain0 := temp_andout;
         temp_tain1 := temp_orout;
      WHEN S6 =>
         temp_ltemp := NOT(temp_xorout);
         temp_tain0 := Left;
         temp_tain1 :=  temp_not_b;
      WHEN S7 =>
         temp_ltemp := temp_orout;
         temp_tain1 := temp_orout;
      WHEN S8 =>
         temp_ltemp := temp_andout;
         temp_tain0 := Left;
         temp_tain1 := temp_orout;
      WHEN S9 =>
         temp_ltemp := temp_xorout;
         temp_tain0 := Left;
         temp_tain1 := Right;
      WHEN S10 =>
         temp_ltemp := Right;
         temp_tain0 := temp_andout;
         temp_tain1 := temp_orout;
      WHEN S11 =>
         temp_ltemp := temp_orout;
         temp_tain1 := temp_orout;
      WHEN S12 =>
         temp_ltemp := (OTHERS => '0');
         temp_tain0 := Left;
         temp_tain1 := Left;
      WHEN S13 =>
         temp_ltemp := NOT(temp_orout);
         temp_tain0 := temp_andout;
         temp_tain1 := Left;
      WHEN S14 =>
         temp_ltemp := temp_andout;
         temp_tain0 := NOT(temp_orout);
         temp_tain1 := Left;
      WHEN S15 =>
         temp_ltemp := Left;
         temp_tain1 := Left;
      WHEN OTHERS =>
         temp_ltemp := (OTHERS => 'X');
         temp_tain0 := (OTHERS => 'X');
         temp_tain1 := (OTHERS => 'X');
      END CASE;
      mw_custom_ALUlout <= temp_ltemp;
      mw_custom_ALUa_in <= temp_tain0;
      mw_custom_ALUb_in <= temp_tain1;
   END PROCESS custom_alumux_proc;

   -- ModuleWare code(v1.12) for instance 'Comparator' of 'cmp'
   comparatorcombo_proc : PROCESS (ALU_Result_internal, dout)
   VARIABLE temp_lgt : std_logic;
   VARIABLE temp_leq : std_logic;
   
   BEGIN
      temp_lgt := '0';
      temp_leq := '0';
      IF (signed(ALU_Result_internal) > signed(dout)) THEN
          temp_lgt := '1';
      ELSIF (signed(ALU_Result_internal) = signed(dout)) THEN
          temp_leq := '1';
      END IF;
      Is_zero <= temp_leq;
      Is_negative <= NOT(temp_lgt OR temp_leq);
   END PROCESS comparatorcombo_proc;

   -- ModuleWare code(v1.12) for instance 'ZERO' of 'constval'
   dout <= "0000000000000000";

   -- ModuleWare code(v1.12) for instance 'pc_increment_Amount' of 'constval'
   dout1 <= "0000000000000001";

   -- Instance port mappings.

   -- Implicit buffered output assignments
   ALU_Result <= ALU_Result_internal;

END struct;
