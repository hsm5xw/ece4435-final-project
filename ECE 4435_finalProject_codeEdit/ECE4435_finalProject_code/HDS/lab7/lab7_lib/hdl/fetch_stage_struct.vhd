-- VHDL Entity lab7_lib.fetch_stage.symbol
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 21:19:13 04/22/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY fetch_stage IS
   PORT( 
      can_move_on : IN     std_logic;
      clk         : IN     std_logic;                       -- input
      interrupt   : IN     std_logic  := '0';               -- input
      jaddr       : IN     std_logic_vector (15 DOWNTO 0);  -- input
      jump        : IN     std_logic  := '0';               -- input
      mdata       : IN     std_logic_vector (15 DOWNTO 0);  -- input
      mdelay      : IN     std_logic  := '0';               -- input
      reset       : IN     std_logic  := '0';               -- input
      stall       : IN     std_logic;
      inst        : OUT    std_logic_vector (15 DOWNTO 0);
      maddr       : OUT    std_logic_vector (15 DOWNTO 0);
      pcval       : OUT    std_logic_vector (15 DOWNTO 0)
   );

-- Declarations

END fetch_stage ;

--
-- VHDL Architecture lab7_lib.fetch_stage.struct
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 07:43:59 04/27/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

LIBRARY lab7_lib;

ARCHITECTURE struct OF fetch_stage IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL PC_Load_Control        : std_logic;
   SIGNAL PC_MUX_Control         : std_logic_vector(1 DOWNTO 0);
   SIGNAL control_bus            : std_logic_vector( 6 DOWNTO 0 );
   SIGNAL dout                   : std_logic_vector(15 DOWNTO 0);
   SIGNAL dout1                  : std_logic;
   SIGNAL dout2                  : std_logic;
   SIGNAL inst_MUX_Control       : std_logic_vector(1 DOWNTO 0);
   SIGNAL maddr_MUX_Control      : std_logic_vector(1 DOWNTO 0);
   SIGNAL pcval_In               : std_logic_vector(15 DOWNTO 0);
   SIGNAL signal_NOP             : std_logic_vector(15 DOWNTO 0);
   SIGNAL signal_ONE             : std_logic_vector(15 DOWNTO 0);     -- on interrupt
   SIGNAL signal_PC_incrementAmt : std_logic_vector(15 DOWNTO 0);
   SIGNAL signal_SPECIAL_INST    : std_logic_vector(15 DOWNTO 0);
   SIGNAL signal_ZERO            : std_logic_vector(15 DOWNTO 0);     -- on startup

   -- Implicit buffer signal declarations
   SIGNAL pcval_internal : std_logic_vector (15 DOWNTO 0);


   -- ModuleWare signal declarations(v1.12) for instance 'PC' of 'adff'
   SIGNAL mw_PCreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'control_splitter' of 'split'
   SIGNAL mw_control_splittertemp_din : std_logic_vector(6 DOWNTO 0);

   -- Component Declarations
   COMPONENT Fetch_FSM
   PORT (
      clock       : IN     std_logic;
      int         : IN     std_logic;
      jump        : IN     std_logic;
      mdelay      : IN     std_logic;
      reset       : IN     std_logic;
      stall       : IN     std_logic;
      control_bus : OUT    std_logic_vector ( 6 DOWNTO 0 )
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : Fetch_FSM USE ENTITY lab7_lib.Fetch_FSM;
   -- pragma synthesis_on


BEGIN

   -- ModuleWare code(v1.12) for instance 'PC_incrementer' of 'add'
   pc_incrementercombo_proc: PROCESS (pcval_internal, signal_PC_incrementAmt)
   VARIABLE temp_din0 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_din1 : std_logic_vector(16 DOWNTO 0);
   VARIABLE temp_sum : unsigned(16 DOWNTO 0);
   VARIABLE temp_carry : std_logic;
   BEGIN
      temp_din0 := '0' & pcval_internal;
      temp_din1 := '0' & signal_PC_incrementAmt;
      temp_carry := '0';
      temp_sum := unsigned(temp_din0) + unsigned(temp_din1) + temp_carry;
      dout <= conv_std_logic_vector(temp_sum(15 DOWNTO 0),16);
   END PROCESS pc_incrementercombo_proc;

   -- ModuleWare code(v1.12) for instance 'PC' of 'adff'
   pcval_internal <= mw_PCreg_cval;
   pcseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (dout2 = '1') THEN
            mw_PCreg_cval <= pcval_In;
         END IF;
      END IF;
   END PROCESS pcseq_proc;

   -- ModuleWare code(v1.12) for instance 'INTERRUPT_INST' of 'constval'
   signal_SPECIAL_INST <= "0000000000000001";

   -- ModuleWare code(v1.12) for instance 'NOP' of 'constval'
   signal_NOP <= "0000000000000000";

   -- ModuleWare code(v1.12) for instance 'ONE' of 'constval'
   signal_ONE <= "0000000000000001";

   -- ModuleWare code(v1.12) for instance 'PC_increment_ONE' of 'constval'
   signal_PC_incrementAmt <= "0000000000000001";

   -- ModuleWare code(v1.12) for instance 'PC_load_ZERO' of 'constval'
   dout1 <= '0';

   -- ModuleWare code(v1.12) for instance 'ZERO' of 'constval'
   signal_ZERO <= "0000000000000000";

   -- ModuleWare code(v1.12) for instance 'PC_Load_MUX' of 'mux'
   pc_load_muxcombo_proc: PROCESS(dout1, PC_Load_Control, can_move_on)
   BEGIN
      CASE can_move_on IS
      WHEN '0' => dout2 <= dout1;
      WHEN '1' => dout2 <= PC_Load_Control;
      WHEN OTHERS => dout2 <= 'X';
      END CASE;
   END PROCESS pc_load_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'PC_MUX' of 'mux'
   pc_muxcombo_proc: PROCESS(mdata, jaddr, dout, PC_MUX_Control)
   BEGIN
      CASE PC_MUX_Control IS
      WHEN "00" => pcval_In <= mdata;
      WHEN "01" => pcval_In <= jaddr;
      WHEN "10" => pcval_In <= dout;
      WHEN OTHERS => pcval_In <= (OTHERS => 'X');
      END CASE;
   END PROCESS pc_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'inst_MUX' of 'mux'
   inst_muxcombo_proc: PROCESS(mdata, signal_NOP, signal_SPECIAL_INST, 
                               inst_MUX_Control)
   BEGIN
      CASE inst_MUX_Control IS
      WHEN "00" => inst <= mdata;
      WHEN "01" => inst <= signal_NOP;
      WHEN "10" => inst <= signal_SPECIAL_INST;
      WHEN OTHERS => inst <= (OTHERS => 'X');
      END CASE;
   END PROCESS inst_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'maddr_MUX' of 'mux'
   maddr_muxcombo_proc: PROCESS(signal_ZERO, signal_ONE, pcval_internal, 
                                maddr_MUX_Control)
   BEGIN
      CASE maddr_MUX_Control IS
      WHEN "00" => maddr <= signal_ZERO;
      WHEN "01" => maddr <= signal_ONE;
      WHEN "10" => maddr <= pcval_internal;
      WHEN OTHERS => maddr <= (OTHERS => 'X');
      END CASE;
   END PROCESS maddr_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'control_splitter' of 'split'
   mw_control_splittertemp_din <= control_bus;
   control_splittercombo_proc: PROCESS (mw_control_splittertemp_din)
   VARIABLE temp_din: std_logic_vector(6 DOWNTO 0);
   BEGIN
      temp_din := mw_control_splittertemp_din(6 DOWNTO 0);
      inst_MUX_Control <= temp_din(1 DOWNTO 0);
      maddr_MUX_Control <= temp_din(3 DOWNTO 2);
      PC_Load_Control <= temp_din(4);
      PC_MUX_Control <= temp_din(6 DOWNTO 5);
   END PROCESS control_splittercombo_proc;

   -- Instance port mappings.
   U_0 : Fetch_FSM
      PORT MAP (
         clock       => clk,
         reset       => reset,
         mdelay      => mdelay,
         stall       => stall,
         jump        => jump,
         int         => interrupt,
         control_bus => control_bus
      );

   -- Implicit buffered output assignments
   pcval <= pcval_internal;

END struct;
