-- VHDL Entity lab10_memory_stage_lib.memory_stage.symbol
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 10:08:30 04/18/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY memory_stage IS
   PORT( 
      Control      : IN     std_logic_vector (2 DOWNTO 0);
      Data_In      : IN     std_logic_vector (15 DOWNTO 0);
      Dest         : IN     std_logic_vector (3 DOWNTO 0);
      Extra        : IN     std_logic_vector (15 DOWNTO 0);
      Result       : IN     std_logic_vector (15 DOWNTO 0);
      clk          : IN     std_logic;
      mdelay       : IN     std_logic;
      Addr         : OUT    std_logic_vector (15 DOWNTO 0);
      Control_toWB : OUT    std_logic;
      Data_Store   : OUT    std_logic_vector (15 DOWNTO 0);
      Dest_toWB    : OUT    std_logic_vector (3 DOWNTO 0);
      R            : OUT    std_logic;
      Value_toWB   : OUT    std_logic_vector (15 DOWNTO 0);
      W            : OUT    std_logic;
      stall        : OUT    std_logic
   );

-- Declarations

END memory_stage ;

--
-- VHDL Architecture lab10_memory_stage_lib.memory_stage.struct
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 01:11:45 04/23/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;


ARCHITECTURE struct OF memory_stage IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL RegWrite   : std_logic;
   SIGNAL dout       : std_logic;
   SIGNAL not_mdelay : std_logic;
   SIGNAL q          : std_logic_vector(2 DOWNTO 0);

   -- Implicit buffer signal declarations
   SIGNAL Addr_internal : std_logic_vector (15 DOWNTO 0);
   SIGNAL R_internal    : std_logic;


   -- ModuleWare signal declarations(v1.12) for instance 'Control_Reg' of 'adff'
   SIGNAL mw_Control_Regreg_cval : std_logic_vector(2 DOWNTO 0) := "000";

   -- ModuleWare signal declarations(v1.12) for instance 'Data_Reg' of 'adff'
   SIGNAL mw_Data_Regreg_cval : std_logic_vector(3 DOWNTO 0) := "0000";

   -- ModuleWare signal declarations(v1.12) for instance 'Extra_Reg' of 'adff'
   SIGNAL mw_Extra_Regreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'Result_Reg' of 'adff'
   SIGNAL mw_Result_Regreg_cval : std_logic_vector(15 DOWNTO 0) := "0000000000000000";

   -- ModuleWare signal declarations(v1.12) for instance 'U_4' of 'split'
   SIGNAL mw_U_4temp_din : std_logic_vector(2 DOWNTO 0);


BEGIN

   -- ModuleWare code(v1.12) for instance 'Control_Reg' of 'adff'
   q <= mw_Control_Regreg_cval;
   control_regseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (not_mdelay = '1') THEN
            mw_Control_Regreg_cval <= Control;
         END IF;
      END IF;
   END PROCESS control_regseq_proc;

   -- ModuleWare code(v1.12) for instance 'Data_Reg' of 'adff'
   Dest_toWB <= mw_Data_Regreg_cval;
   data_regseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (not_mdelay = '1') THEN
            mw_Data_Regreg_cval <= Dest;
         END IF;
      END IF;
   END PROCESS data_regseq_proc;

   -- ModuleWare code(v1.12) for instance 'Extra_Reg' of 'adff'
   Data_Store <= mw_Extra_Regreg_cval;
   extra_regseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (not_mdelay = '1') THEN
            mw_Extra_Regreg_cval <= Extra;
         END IF;
      END IF;
   END PROCESS extra_regseq_proc;

   -- ModuleWare code(v1.12) for instance 'Result_Reg' of 'adff'
   Addr_internal <= mw_Result_Regreg_cval;
   result_regseq_proc: PROCESS (clk)BEGIN
      IF (clk'EVENT AND clk='1') THEN
         IF (not_mdelay = '1') THEN
            mw_Result_Regreg_cval <= Result;
         END IF;
      END IF;
   END PROCESS result_regseq_proc;

   -- ModuleWare code(v1.12) for instance 'buf' of 'buff'
   stall <= mdelay;

   -- ModuleWare code(v1.12) for instance 'Stall_Equiv' of 'constval'
   dout <= '0';

   -- ModuleWare code(v1.12) for instance 'mdelay_inverter' of 'inv'
   not_mdelay <= NOT(mdelay);

   -- ModuleWare code(v1.12) for instance 'Control_MUX' of 'mux'
   control_muxcombo_proc: PROCESS(RegWrite, dout, mdelay)
   BEGIN
      CASE mdelay IS
      WHEN '0' => Control_toWB <= RegWrite;
      WHEN '1' => Control_toWB <= dout;
      WHEN OTHERS => Control_toWB <= 'X';
      END CASE;
   END PROCESS control_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'Value_MUX' of 'mux'
   value_muxcombo_proc: PROCESS(Addr_internal, Data_In, R_internal)
   BEGIN
      CASE R_internal IS
      WHEN '0' => Value_toWB <= Addr_internal;
      WHEN '1' => Value_toWB <= Data_In;
      WHEN OTHERS => Value_toWB <= (OTHERS => 'X');
      END CASE;
   END PROCESS value_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'U_4' of 'split'
   mw_U_4temp_din <= q;
   u_4combo_proc: PROCESS (mw_U_4temp_din)
   VARIABLE temp_din: std_logic_vector(2 DOWNTO 0);
   BEGIN
      temp_din := mw_U_4temp_din(2 DOWNTO 0);
      W <= temp_din(0);
      R_internal <= temp_din(1);
      RegWrite <= temp_din(2);
   END PROCESS u_4combo_proc;

   -- Instance port mappings.

   -- Implicit buffered output assignments
   Addr <= Addr_internal;
   R    <= R_internal;

END struct;
