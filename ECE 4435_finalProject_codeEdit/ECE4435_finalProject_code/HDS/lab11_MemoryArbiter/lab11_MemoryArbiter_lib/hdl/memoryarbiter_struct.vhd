-- VHDL Entity lab11_MemoryArbiter_lib.MemoryArbiter.symbol
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 02:31:01 04/23/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY MemoryArbiter IS
   PORT( 
      Addr_fromFetchStage : IN     std_logic_vector (15 DOWNTO 0);
      Addr_fromMemStage   : IN     std_logic_vector (15 DOWNTO 0);
      R                   : IN     std_logic;
      W                   : IN     std_logic;
      reset               : IN     std_logic;
      Addr_toMemory       : OUT    std_logic_vector (15 DOWNTO 0);
      Write_Control       : OUT    std_logic;
      mdelay_toFetchStage : OUT    std_logic;
      mdelay_toMemStage   : OUT    std_logic
   );

-- Declarations

END MemoryArbiter ;

--
-- VHDL Architecture lab11_MemoryArbiter_lib.MemoryArbiter.struct
--
-- Created:
--          by - Hong.Hong (HSM)
--          at - 02:31:01 04/23/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;


ARCHITECTURE struct OF MemoryArbiter IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL dout  : std_logic;
   SIGNAL dout1 : std_logic;
   SIGNAL dout2 : std_logic;

   -- Implicit buffer signal declarations
   SIGNAL mdelay_toFetchStage_internal : std_logic;



BEGIN

   -- ModuleWare code(v1.12) for instance 'ZERO' of 'constval'
   mdelay_toMemStage <= '0';

   -- ModuleWare code(v1.12) for instance 'ZERO_a' of 'constval'
   dout <= '0';

   -- ModuleWare code(v1.12) for instance 'ZERO_b' of 'constval'
   dout2 <= '0';

   -- ModuleWare code(v1.12) for instance 'U_0' of 'mux'
   u_0combo_proc: PROCESS(dout1, dout, reset)
   BEGIN
      CASE reset IS
      WHEN '0' => mdelay_toFetchStage_internal <= dout1;
      WHEN '1' => mdelay_toFetchStage_internal <= dout;
      WHEN OTHERS => mdelay_toFetchStage_internal <= 'X';
      END CASE;
   END PROCESS u_0combo_proc;

   -- ModuleWare code(v1.12) for instance 'WE_MUX' of 'mux'
   we_muxcombo_proc: PROCESS(W, dout2, reset)
   BEGIN
      CASE reset IS
      WHEN '0' => Write_Control <= W;
      WHEN '1' => Write_Control <= dout2;
      WHEN OTHERS => Write_Control <= 'X';
      END CASE;
   END PROCESS we_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'to_MemAddr_MUX' of 'mux'
   to_memaddr_muxcombo_proc: PROCESS(Addr_fromFetchStage, 
                                     Addr_fromMemStage, 
                                     mdelay_toFetchStage_internal)
   BEGIN
      CASE mdelay_toFetchStage_internal IS
      WHEN '0' => Addr_toMemory <= Addr_fromFetchStage;
      WHEN '1' => Addr_toMemory <= Addr_fromMemStage;
      WHEN OTHERS => Addr_toMemory <= (OTHERS => 'X');
      END CASE;
   END PROCESS to_memaddr_muxcombo_proc;

   -- ModuleWare code(v1.12) for instance 'toMemAddr_Control' of 'or'
   dout1 <= R OR W;

   -- Instance port mappings.

   -- Implicit buffered output assignments
   mdelay_toFetchStage <= mdelay_toFetchStage_internal;

END struct;
